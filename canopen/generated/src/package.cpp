
// AUTO GENERATED by vnxcppcodegen

#include <pilot/base/canopen/emcy_code_e.hxx>
#include <pilot/base/canopen/emcy_register_e.hxx>
#include <pilot/base/canopen/nmt_command_e.hxx>
#include <pilot/base/canopen/nmt_state_e.hxx>
#include <pilot/base/canopen/node_t.hxx>
#include <pilot/base/canopen/sdo_ccs_e.hxx>
#include <pilot/base/canopen/sdo_error_e.hxx>
#include <pilot/base/canopen/sdo_scs_e.hxx>

#include <pilot/base/canopen/package.hxx>
#include <vnx/vnx.h>



namespace vnx {

void type<::pilot::base::canopen::emcy_code_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::emcy_code_e());
}

void type<::pilot::base::canopen::emcy_code_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::emcy_code_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::emcy_register_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::emcy_register_e());
}

void type<::pilot::base::canopen::emcy_register_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::emcy_register_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::nmt_command_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::nmt_command_e());
}

void type<::pilot::base::canopen::nmt_command_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::nmt_command_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::nmt_state_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::nmt_state_e());
}

void type<::pilot::base::canopen::nmt_state_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::nmt_state_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::node_t>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::node_t());
}

void type<::pilot::base::canopen::node_t>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::node_t& value, bool special) {
	code.push_back(CODE_OBJECT);
}

void type<::pilot::base::canopen::sdo_ccs_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::sdo_ccs_e());
}

void type<::pilot::base::canopen::sdo_ccs_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::sdo_ccs_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::sdo_error_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::sdo_error_e());
}

void type<::pilot::base::canopen::sdo_error_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::sdo_error_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

void type<::pilot::base::canopen::sdo_scs_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::pilot::base::canopen::sdo_scs_e());
}

void type<::pilot::base::canopen::sdo_scs_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::pilot::base::canopen::sdo_scs_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}


} // namespace vnx


namespace pilot {
namespace base {
namespace canopen {


static void register_all_types() {
	vnx::register_type_code(::pilot::base::canopen::emcy_code_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::emcy_register_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::nmt_command_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::nmt_state_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::node_t::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::sdo_ccs_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::sdo_error_e::static_create_type_code());
	vnx::register_type_code(::pilot::base::canopen::sdo_scs_e::static_create_type_code());
}

static struct vnx_static_init {
	vnx_static_init() {
		register_all_types();
	}
} vnx_static_init_;

const vnx::TypeCode* const vnx_native_type_code_emcy_code_e = vnx::get_type_code(vnx::Hash64(0xc0297cb989826ca8ull));
const vnx::TypeCode* const vnx_native_type_code_emcy_register_e = vnx::get_type_code(vnx::Hash64(0x32d1884c3357098ull));
const vnx::TypeCode* const vnx_native_type_code_nmt_command_e = vnx::get_type_code(vnx::Hash64(0xbf49909e851a6027ull));
const vnx::TypeCode* const vnx_native_type_code_nmt_state_e = vnx::get_type_code(vnx::Hash64(0x9abbd74df7288da4ull));
const vnx::TypeCode* const vnx_native_type_code_node_t = vnx::get_type_code(vnx::Hash64(0x2368a77e3516a12aull));
const vnx::TypeCode* const vnx_native_type_code_sdo_ccs_e = vnx::get_type_code(vnx::Hash64(0x8a645138249edad3ull));
const vnx::TypeCode* const vnx_native_type_code_sdo_error_e = vnx::get_type_code(vnx::Hash64(0x9b27dfeddc64e9c2ull));
const vnx::TypeCode* const vnx_native_type_code_sdo_scs_e = vnx::get_type_code(vnx::Hash64(0x2660c5c2faf8982dull));

} // namespace pilot
} // namespace base
} // namespace canopen
